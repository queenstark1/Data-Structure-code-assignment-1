 1. STACK (LIFO - Last In First Out)


class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)
        print(item, "pushed to stack")

    def pop(self):
        if self.is_empty():
            print("Stack underflow")
            return None
        return self.items.pop()

    def peek(self):
        if self.is_empty():
            return None
        return self.items[-1]

    def is_empty(self):
        return len(self.items) == 0


 2. QUEUE (FIFO - First In First Out)


class Queue:
    def __init__(self):
        self.items = []

    def enqueue(self, item):
        self.items.append(item)
        print(item, "added to queue")

    def dequeue(self):
        if self.is_empty():
            print("Queue underflow")
            return None
        return self.items.pop(0)

    def is_empty(self):
        return len(self.items) == 0


 3. LINKED LIST


class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None

    def insert(self, data):
        new_node = Node(data)

        if not self.head:
            self.head = new_node
            return

        temp = self.head
        while temp.next:
            temp = temp.next

        temp.next = new_node

    def display(self):
        temp = self.head
        while temp:
            print(temp.data, end=" -> ")
            temp = temp.next
        print("None")


 4. TREE (Binary Tree)


class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None


class BinaryTree:
    def __init__(self, root_value):
        self.root = TreeNode(root_value)

    def inorder(self, node):
        if node:
            self.inorder(node.left)
            print(node.value, end=" ")
            self.inorder(node.right)


5. GRAPH (Adjacency List)

class Graph:
    def __init__(self):
        self.graph = {}

    def add_edge(self, u, v):
        if u not in self.graph:
            self.graph[u] = []
        self.graph[u].append(v)

    def display(self):
        for node in self.graph:
            print(node, "->", self.graph[node])

 PYTHON ARRAY (LIST) SYNTAX


1Ô∏è‚É£ Creating an array (list)
numbers = [10, 20, 30, 40, 50]

 2Ô∏è‚É£ Accessing elements (index starts at 0)
print("First element:", numbers[0])      # 10
print("Third element:", numbers[2])      # 30

 3Ô∏è‚É£ Negative indexing (from the end)
print("Last element:", numbers[-1])      # 50

 4Ô∏è‚É£ Modifying an element
numbers[1] = 25
print("After modification:", numbers)

 5Ô∏è‚É£ Adding elements
numbers.append(60)        # Add at end
numbers.insert(2, 15)     # Insert at index 2
print("After adding:", numbers)

 6Ô∏è‚É£ Removing elements
numbers.remove(40)        # Remove by value
del numbers[0]            # Remove by index
print("After removing:", numbers)

 7Ô∏è‚É£ Length of array
print("Length:", len(numbers))

 8Ô∏è‚É£ Looping through array
print("Looping through array:")
for item in numbers:
    print(item)

 9Ô∏è‚É£ Slicing (getting a range of elements)
print("Slice [1:4]:", numbers[1:4])

 üîü Checking if value exists
if 25 in numbers:
    print("25 exists in the array")



** TESTING ALL DATA STRUCTURES


if __name__ == "__main__":

    print("\n--- ARRAY ---")
    arr = [10, 20, 30, 40, 50]   # Creating an array (list)

    print("Original array:", arr)

    # Accessing element
    print("First element:", arr[0])

    # Adding element
    arr.append(60)
    print("After append:", arr)

    # Inserting element
    arr.insert(2, 25)
    print("After insert at index 2:", arr)

    # Removing element
    arr.remove(40)
    print("After removing 40:", arr)

    # Looping through array
    print("Looping through array:")
    for item in arr:
        print(item)

    print("\n--- STACK ---")
    s = Stack()
    s.push(10)
    s.push(20)
    print("Popped:", s.pop())

    print("\n--- QUEUE ---")
    q = Queue()
    q.enqueue(1)
    q.enqueue(2)
    print("Dequeued:", q.dequeue())

    print("\n--- LINKED LIST ---")
    ll = LinkedList()
    ll.insert(5)
    ll.insert(10)
    ll.insert(15)
    ll.display()

    print("\n--- BINARY TREE ---")
    tree = BinaryTree(10)
    tree.root.left = TreeNode(5)
    tree.root.right = TreeNode(20)
    print("Inorder traversal:")
    tree.inorder(tree.root)

    print("\n\n--- GRAPH ---")
    g = Graph()
    g.add_edge("A", "B")
    g.add_edge("A", "C")
    g.add_edge("B", "D")
    g.display()
